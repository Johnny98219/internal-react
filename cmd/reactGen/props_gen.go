package main

import (
	"go/ast"
	"strings"
	"unicode"
	"unicode/utf8"

	"myitcv.io/gogenerate"
)

type propsGen struct {
	*coreGen

	Recv string
	Name string
	Doc  string

	Fields []field
}

func (g *gen) genProps(defName string, t typeFile) {

	name := strings.TrimPrefix(defName, propsTypeTmplPrefix)

	r, _ := utf8.DecodeRuneInString(name)

	pg := &propsGen{
		coreGen: newCoreGen(g),
		Name:    name,
		Recv:    string(unicode.ToLower(r)),
	}

	var doc string

	if v := t.ts.Doc; v != nil {
		for _, c := range v.List {
			doc = doc + strings.Replace(c.Text, defName, name, -1)
		}
	}

	pg.Doc = doc

	fe := &fieldExploder{
		first:  true,
		pkgStr: g.pkgImpPath,
		sn:     t.ts.Name.Name,
		imps:   make(map[*ast.ImportSpec]struct{}),
	}

	err := fe.explode()
	if err != nil {
		fatalf("could not explode fields: %v", err)
	}

	pg.Fields = fe.fields

	pg.pf("// Code generated by %v. DO NOT EDIT.\n", reactGenCmd)
	pg.pln()
	pg.pf("package %v\n", pg.pkg)

	if !g.isReactCore {
		pg.pf("import \"%v\"\n", reactPkg)
	}

	for is := range fe.imps {
		if is.Name != nil {
			pg.pf("import %v %v", is.Name.Name, is.Path.Value)
		} else {
			pg.pf("import %v", is.Path.Value)
		}
	}

	pg.pln()

	// TODO the ID/Key hack below feels fragile...
	pg.pt(`
	{{ $recv := .Recv }}

	{{.Doc}}
	type {{.Name}} struct {
	{{range .Fields}}
		{{.Name}} {{.Type}}
	{{- end}}
	}

	func ({{$recv}} *{{.Name}}) assign(v *_{{.Name}}) {
		{{- range .Fields}}
			{{ if .Omit }}
				if {{$recv}}.{{.Name}} != "" {
					v.{{.Name}} = {{$recv}}.{{.Name}}
				}
			{{else}}
				v.{{.Name}} = {{$recv}}.{{.Name}}
			{{end}}
		{{- end}}
	}
	`, pg)

	ofName := gogenerate.NameFile(name, reactGenCmd)
	toWrite := pg.buf.Bytes()

	out, err := fmtBuf(pg.buf)
	if err == nil {
		toWrite = out.Bytes()
	}

	wrote, err := gogenerate.WriteIfDiff(toWrite, ofName)
	if err != nil {
		fatalf("could not write %v: %v", ofName, err)
	}

	if wrote {
		infof("writing %v", ofName)
	} else {
		infof("skipping writing of %v; it's identical", ofName)
	}

}
