package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"path"
	"strings"
	"text/template"

	"golang.org/x/tools/imports"

	"github.com/myitcv/gogenerate"
)

const (
	ReactPkg      = "github.com/myitcv/gopherjs/react"
	CompDefName   = "ComponentDef"
	CompDefSuffix = "Def"

	StateTypeSuffix = "State"
	PropsTypeSuffix = "Props"

	GetInitialState = "GetInitialState"
)

type gen struct {
	fset *token.FileSet

	pkg string

	components map[string]*ast.TypeSpec
	types      map[string]*ast.TypeSpec
	methods    map[string][]*ast.FuncDecl
}

func dogen(dir, license string) {
	fset := token.NewFileSet()

	pkgs, err := parser.ParseDir(fset, dir, nil, 0)
	if err != nil {
		fatalf("unable to parse %v: %v", dir, err)
	}

	// we intentionally walk all packages, i.e. the package in the current directory
	// and any x-test package that may also be present
	for pn, pkg := range pkgs {
		g := &gen{
			fset: fset,
			pkg:  pn,

			components: make(map[string]*ast.TypeSpec),
			types:      make(map[string]*ast.TypeSpec),
			methods:    make(map[string][]*ast.FuncDecl),
		}

		for fn, file := range pkg.Files {

			if gogenerate.FileGeneratedBy(fn, "reactGen") {
				continue
			}

			foundImp := false
			impName := ""

			for _, i := range file.Imports {
				p := strings.Trim(i.Path.Value, "\"")

				if p == ReactPkg {
					foundImp = true

					if i.Name != nil {
						impName = i.Name.Name
					} else {
						impName = path.Base(ReactPkg)
					}

					break
				}
			}

			if !foundImp {
				continue
			}

			for _, d := range file.Decls {
				switch d := d.(type) {
				case *ast.FuncDecl:
					if d.Recv == nil {
						continue
					}

					f := d.Recv.List[0]

					se, ok := f.Type.(*ast.StarExpr)
					if !ok {
						continue
					}

					id, ok := se.X.(*ast.Ident)
					if !ok {
						continue
					}

					g.methods[id.Name] = append(g.methods[id.Name], d)

				case *ast.GenDecl:
					if d.Tok != token.TYPE {
						continue
					}

					for _, ts := range d.Specs {
						ts := ts.(*ast.TypeSpec)

						st, ok := ts.Type.(*ast.StructType)
						if !ok || st.Fields == nil {
							continue
						}

						foundAnon := false

						for _, f := range st.Fields.List {
							if f.Names != nil {
								// it must be anonymous
								continue
							}

							se, ok := f.Type.(*ast.SelectorExpr)
							if !ok {
								continue
							}

							if se.Sel.Name != CompDefName {
								continue
							}

							id, ok := se.X.(*ast.Ident)
							if !ok {
								continue
							}

							if id.Name != impName {
								continue
							}

							foundAnon = true
						}

						if foundAnon && strings.HasSuffix(ts.Name.Name, CompDefSuffix) {
							g.components[ts.Name.Name] = ts
						} else {
							g.types[ts.Name.Name] = ts
						}
					}
				}
			}
		}

		// at this point we have the components and their methods
		for cd := range g.components {
			g.genComp(cd)
		}
	}
}

type compGen struct {
	*gen

	Name string

	HasState        bool
	HasProps        bool
	HasGetInitState bool

	buf *bytes.Buffer
}

func (g *gen) genComp(defName string) {

	name := strings.TrimSuffix(defName, CompDefSuffix)

	cg := &compGen{
		gen:  g,
		buf:  bytes.NewBuffer(nil),
		Name: name,
	}

	_, hasState := g.types[name+StateTypeSuffix]
	_, hasProps := g.types[name+PropsTypeSuffix]

	cg.HasState = hasState
	cg.HasProps = hasProps

	if hasState {
		for _, m := range g.methods[defName] {
			if m.Name.Name != GetInitialState {
				continue
			}

			if m.Type.Params != nil && len(m.Type.Params.List) > 0 {
				continue
			}

			if m.Type.Results != nil && len(m.Type.Results.List) != 1 {
				continue
			}

			rp := m.Type.Results.List[0]

			id, ok := rp.Type.(*ast.Ident)
			if !ok {
				continue
			}

			if id.Name == name+StateTypeSuffix {
				cg.HasGetInitState = true
				break
			}

		}
	}

	cg.pf("// Do not edit: file generated by %v\n", reactGenCmd)
	cg.pln()
	cg.pf("package %v\n", cg.pkg)
	cg.pf("import \"%v\"\n", ReactPkg)
	cg.pln()

	cg.pt(`
{{if .HasState}}
func (p *{{.Name}}Def) SetState(s {{.Name}}State) {
	p.ComponentDef.SetState(s)
}

func (p *{{.Name}}Def) State() {{.Name}}State {
	return p.ComponentDef.State().({{.Name}}State)
}

func (p {{.Name}}State) IsState() {}

func (p *{{.Name}}Def) GetInitialStateIntf() react.State {
{{if .HasGetInitState -}}
	return p.GetInitialState()
{{else -}}
	return {{.Name}}State{}
{{end -}}
}
{{end}}


{{if .HasProps}}
func (p *{{.Name}}Def) Props() {{.Name}}Props {
	uprops := p.ComponentDef.Props()
	return uprops.({{.Name}}Props)
}
{{end}}
	`, cg)

	ofName := gogenerate.NameFile(name, reactGenCmd)
	toWrite := cg.buf.Bytes()

	res, err := imports.Process(ofName, toWrite, nil)
	if err == nil {
		toWrite = res
	}

	wrote, err := gogenerate.WriteIfDiff(toWrite, ofName)
	if err != nil {
		fatalf("could not write %v: %v", ofName, err)
	}

	if wrote {
		infof("writing %v", ofName)
	} else {
		infof("skipping writing of %v; it's identical", ofName)
	}

}

func (c *compGen) pf(format string, vals ...interface{}) {
	fmt.Fprintf(c.buf, format, vals...)
}

func (c *compGen) pln(vals ...interface{}) {
	fmt.Fprintln(c.buf, vals...)
}

func (c *compGen) pt(tmpl string, val interface{}) {
	// on the basis most templates are for convenience define inline
	// as raw string literals which start the ` on one line but then start
	// the template on the next (for readability) we strip the first leading
	// \n if one exists
	tmpl = strings.TrimPrefix(tmpl, "\n")

	t := template.New("tmp")

	_, err := t.Parse(tmpl)
	if err != nil {
		fatalf("unable to parse template: %v", err)
	}

	err = t.Execute(c.buf, val)
	if err != nil {
		fatalf("cannot execute template: %v", err)
	}
}
