// Code generated by immutableGen

package examples

import (
	"github.com/myitcv/immutable"
)

//
// exampleS is an immutable type and has the following template:
//
// 	[]*example
//
type exampleS struct {
	theSlice []*example
	mutable  bool
	__tmpl   _Imm_exampleS
}

var _ immutable.Immutable = &exampleS{}

func newExampleS(s ...*example) *exampleS {
	c := make([]*example, len(s))
	copy(c, s)

	return &exampleS{
		theSlice: c,
	}
}

func newExampleSLen(l int) *exampleS {
	c := make([]*example, l)

	return &exampleS{
		theSlice: c,
	}
}

func (m *exampleS) Mutable() bool {
	return m.mutable
}

func (m *exampleS) Len() int {
	if m == nil {
		return 0
	}

	return len(m.theSlice)
}

func (m *exampleS) Get(i int) *example {
	return m.theSlice[i]
}

func (m *exampleS) AsMutable() *exampleS {
	if m == nil {
		return nil
	}

	if m.Mutable() {
		return m
	}

	res := m.dup()
	res.mutable = true

	return res
}

func (m *exampleS) dup() *exampleS {
	resSlice := make([]*example, len(m.theSlice))

	for i := range m.theSlice {
		resSlice[i] = m.theSlice[i]
	}

	res := &exampleS{
		theSlice: resSlice,
	}

	return res
}

func (m *exampleS) AsImmutable(v *exampleS) *exampleS {
	if m == nil {
		return nil
	}

	if v == m {
		return m
	}

	m.mutable = false
	return m
}

func (m *exampleS) Range() []*example {
	if m == nil {
		return nil
	}

	return m.theSlice
}

func (m *exampleS) WithMutable(f func(mi *exampleS)) *exampleS {
	res := m.AsMutable()
	f(res)
	res = res.AsImmutable(m)

	return res
}

func (m *exampleS) WithImmutable(f func(mi *exampleS)) *exampleS {
	prev := m.mutable
	m.mutable = false
	f(m)
	m.mutable = prev

	return m
}

func (m *exampleS) Set(i int, v *example) *exampleS {
	if m.mutable {
		m.theSlice[i] = v
		return m
	}

	res := m.dup()
	res.theSlice[i] = v

	return res
}

func (m *exampleS) Append(v ...*example) *exampleS {
	if m.mutable {
		m.theSlice = append(m.theSlice, v...)
		return m
	}

	res := m.dup()
	res.theSlice = append(res.theSlice, v...)

	return res
}

func (m *exampleS) AppendSlice(v *exampleS) *exampleS {
	return m.Append(v.Range()...)
}

func (m *exampleS) ToSlice() []*example {
	if m == nil || m.theSlice == nil {
		return nil
	}

	res := make([]*example, len(m.theSlice))
	copy(res, m.theSlice)

	return res
}

//
// tabS is an immutable type and has the following template:
//
// 	[]tab
//
type tabS struct {
	theSlice []tab
	mutable  bool
	__tmpl   _Imm_tabS
}

var _ immutable.Immutable = &tabS{}

func newTabS(s ...tab) *tabS {
	c := make([]tab, len(s))
	copy(c, s)

	return &tabS{
		theSlice: c,
	}
}

func newTabSLen(l int) *tabS {
	c := make([]tab, l)

	return &tabS{
		theSlice: c,
	}
}

func (m *tabS) Mutable() bool {
	return m.mutable
}

func (m *tabS) Len() int {
	if m == nil {
		return 0
	}

	return len(m.theSlice)
}

func (m *tabS) Get(i int) tab {
	return m.theSlice[i]
}

func (m *tabS) AsMutable() *tabS {
	if m == nil {
		return nil
	}

	if m.Mutable() {
		return m
	}

	res := m.dup()
	res.mutable = true

	return res
}

func (m *tabS) dup() *tabS {
	resSlice := make([]tab, len(m.theSlice))

	for i := range m.theSlice {
		resSlice[i] = m.theSlice[i]
	}

	res := &tabS{
		theSlice: resSlice,
	}

	return res
}

func (m *tabS) AsImmutable(v *tabS) *tabS {
	if m == nil {
		return nil
	}

	if v == m {
		return m
	}

	m.mutable = false
	return m
}

func (m *tabS) Range() []tab {
	if m == nil {
		return nil
	}

	return m.theSlice
}

func (m *tabS) WithMutable(f func(mi *tabS)) *tabS {
	res := m.AsMutable()
	f(res)
	res = res.AsImmutable(m)

	return res
}

func (m *tabS) WithImmutable(f func(mi *tabS)) *tabS {
	prev := m.mutable
	m.mutable = false
	f(m)
	m.mutable = prev

	return m
}

func (m *tabS) Set(i int, v tab) *tabS {
	if m.mutable {
		m.theSlice[i] = v
		return m
	}

	res := m.dup()
	res.theSlice[i] = v

	return res
}

func (m *tabS) Append(v ...tab) *tabS {
	if m.mutable {
		m.theSlice = append(m.theSlice, v...)
		return m
	}

	res := m.dup()
	res.theSlice = append(res.theSlice, v...)

	return res
}

func (m *tabS) AppendSlice(v *tabS) *tabS {
	return m.Append(v.Range()...)
}

func (m *tabS) ToSlice() []tab {
	if m == nil || m.theSlice == nil {
		return nil
	}

	res := make([]tab, len(m.theSlice))
	copy(res, m.theSlice)

	return res
}
